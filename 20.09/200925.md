200925_TIL
===

일일 회고
---

1. "배움"보다 더 어려운 것은, "배움의 실천"이라는 생각이 들었다.

    오늘은 코딩테스트 문제를 풀었다. 그리고, 지금도 여전히 한 문제를 넘어가지 못해서 씨름을 하고 있다. `while`, `if`, `for`, `let`을 쓰면 쉽게 풀릴 문제를 굳이 배운대로 해보겠다고, 계속 해매면서 문제를 풀고 있다. 배우는 것도 어렵지만, 타협하지 않고 배움을 실천하는 것은 더 어렵다는 생각이 들었다.

2. 답을 얻었을 때보다 답을 얻기 위해 고민하는 과정에서 더 많이 배우게 된다.

    결국, 고생 끝에 `while`, `if`, `for`, `let` 없이 데이터의 immutability를 지키면서 코드를 짜는 방법을 찾게 됐다. recursive 하게 코드를 만들면 내가 의도한 바대로 문제를 해결할 수 있었다. 주어진 몇 개의 테스트은 통과해서 기쁜 마음으로 코드를 채점했는데, 몇 개 케이스에 대해서 테스트가 통과하지 못하고 run time error를 반환했다. run time error의 원인을 찾아보니 recursion으로 인한 stack overflow가 문제였음을 알 수 있었다. 여기서 또 나는 결정을 내려야했다. 쉬운 방법을 찾아갈지, 아니면 더 나은 해결책을 힘들지만 찾아볼지. 나는 후자를 선택해보기로 했다. 그래서 functional programming에서 while 을 표현하는 방법이 무엇인지 찾아봤으며, recursion으로 인한 stack overflow를 해결하는 방법을 찾아봤다. 인터넷을 찾아보다가 우연히 "tail recursion"에 대하여 알게 됐고 코드스피츠의 tail recursion 강의를 듣게 됐다. 이 강의를 통해 상호 참조가 왜 안 좋은지, 왜 우리가 굳이 spread operator를 써서 복사본을 넘겨야 하는지를 알게됐다. 왜 코드숨에서 삼항연산자와 AND, OR 연산자를 쓰라고 하는지도 알게되었다. 이 세가지 연산자는 스택 메모리를 잡아먹지 않는다는 특징을 가지고 있었다. tail recursion optimization을 하기 위한 좋은 방법을 알게 됐다. 이러한 새로운 배움들을 다시 곱씹어보고 있는 지금, 나는 여전히 문제에 대한 답을 찾지는 못했다. 그렇지만 답을 얻기 위해 쓴 시간들이 적어도 쉽게 얻은 답보다 더 가치있다는 것을 발견하게 되었다.

3. 나중에 한 번 정리해보면 좋을 것들

    이 문제를 풀고 나면, 꼭 문제 풀이의 과정을 복기해봐야겠다는 생각이 들었다. 이 문제를 통해 `push`, `pop`을 사용하지 않고 stack과 queue를 구현하는 방법이 무엇일지 고민해보는 것도 의미있을 거 같다. functional programming의 의의와 정확한 정의 그리고 조건이 무엇인지도 생각해보면 좋을 거 같다. 무엇보다도 functional programming에서 `let`과 `while`을 대신할 방법을 찾아보고 싶다. tail recursion optimization 이 정확하게 어떤 것인지 이해해보고 싶고, 이 것이 클로저와는 어떤관계가 있는지 (혹은, 아예 관계가 없는 것인지) 알아보고 싶다.

문제를 풀며 정리한 것
---

1. array에 값이 있나 확인하기
```javascript
array.includes(value);
```

2. 몫, 나머지
```javascript
const q = parseInt(3 / 2);
const r = 3 % 2;
```

3. 올림, 내림, 반올림
```javascript
Math.ceil(value) //올림
Math.floor(value) //내림
Math.round(value) //반올림
```

4. String 뒤집기
```javascript
str.split('').reverse().join('');
```

5. 같은 값으로 array 채우기
```javascript
const arr = Array(6).fill(0);
```

6. `reduce` 사용할 때 0 써주기
```javascript
arr.reduce(sum, 0);
// arr = [] 인 경우 에러가 아니라 0 을 반환해줌 
```

7. 런타임 오류의 원인
* 배열에 할당된 크기를 넘어서 접근했을 때
* 전역 배열의 크기가 메모리 제한을 초과할 때
* 지역 배열의 크기가 스택 크기 제한을 넘어갈 때
* 0으로 나눌 떄
* 라이브러리에서 예외를 발생시켰을 때
* 재귀 호출이 너무 깊어질 때
* 이미 해제된 메모리를 또 참조할 때
