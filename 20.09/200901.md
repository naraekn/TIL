200901_TIL
===

### [오늘 하루 느낀 점]
이력서에는 학습이 빠른 사람이라고 썼지만, 사실 나는 느린 사람이다. 남들에게는 쉬울 수 있는 그 하나를 이해하기 위해서, 나는 다양한 곳의 정의를 찾아보고 내가 이해할 수 있고 와닿는 언어들을 수집해야만 한다. 쉽게 들은 이야기들을 혼자서 머릿속으로 천천히 고민 해보는 시간이 꼭 필요한 사람이기도 하다. 오늘도 내가 들은 내용들을 내 것이 되게 만들기 위해서, 이야기를 듣고 난 후 나에게 필요한 느린 시간들을 채워 나갔다. 그 느린 시간들을 통해 오늘 듣고 본 것들이 정말 내 것이 되었는지는 의문이지만, 적어도 최선의 시도들을 했다는 것으로 오늘은 만족할 수 있을 거 같다.

---

오늘 들은 내용 & 공부한 내용 다시 정리해보기
---

## 1. this

this에는 "호출한 주체"에 대한 정보, 즉 호출한 객체를 가르킨다. 실행컨텍스트가 저장될 때 thisBinding에 해당 정보가 저장된다. 실행할 주체를 지정하지 않은 경우에는 전역 객체를 바라보도록 한다. javascript의 this는 런타임시 결정된다.

### this의 쓰임
* **전역공간**: 전역공간에서 this는 전역객체를 바라본다. 전역객체를 브라우저에서는 window, Node.js에서는 global이라고 부른다.
* **메서드로 호출할 때**: 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다. (함수 앞에 '.'이 있다면, 이건 메서드이다) this는 호출한 대상객체를 가르킨다. 
* **함수로 호출할 때**: 함수를 독립적인 기능 수행하는 함수는 실행될 주체가 명시되지 않아 전역객체를 가르킨다. 
    * 재밌게 읽은 것중 하나는, 더글라그 크락포드는 이를 설계상의 오류라고 지적하고 있다. 사실, 호출주체가 없을 때 자동으로 전역객체를 바인당하는 것보다는, 함수 호출 당시 주변 환경의 this를 그대로 받아오도록 하는 것이 자바스크립트가 지향하는 바와 맞기 떄문이다. 실제로, 변수의 스코프에서도 스코프체인을 타고 가장 가까이에 있는 실행컨텍스트를 참조하도록 되어있다. 프로토타입 체인도 비슷하게 동작한다. 
    * 이 때, 화살표함수는 예외 사항이다. this 바인딩하는 과정자체에서 제외되며, 접근하고자하는 스코프체인 상 가장 가까운 this를 바인딩한다. 어쩌면 "오류"라고 지적되었던 부분을 해결할 수 있는 새로운 방법이기도 하다.

* **콜백함수 호출할 때**: 콜백함수의 this는 제어권을 가진 함수에 따라 this가 결정된다. 특별하게 정의되지 않은 경우 전역객체를 바라본다.
* **생성자함수 내부에서**: 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 되도록 한다.
    * 생성자 함수 - new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로 동작하게 된다.

### this를 명시적으로 지정해줄 수는 없을까?

* call: 메서드의 호출주체인 함수를 즉시 실행하도록 하는 명령이다. 첫번째 인자를 this로 바인딩한다. 
* apply: call 과 기능이 같으며, 두번째인자를 배열로 받는다.
* bind: call과 비슷하나, 즉시 호출하지 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 한다. 


## 2. 클로저

클로저 함수란, "**실행 컨텍스트**"가 종료 되면 함수의 생명 주기가 끝나서 함수 내부에 있는 변수가 사라져야 하지만, 그 변수가 사라지지 않고 캡처 돼서 해당 함수에서 살아있는 함수를 말한다.

[**어디에 사용하는가?]**

1) 클래스가 없었을 당시, 클로저를 활용해서 함수로 객체지향프로그래밍을 할 떄 쓰기도 했다. 안에서는 접근가능하지만, 외부에서는 직접적으로 접근 불가능한 할 수 있다.

2) **"커링**"이나 "**부분 적용**" 할 때 쓴다. 

(부분 적용 함수 - 부분적으로 실행을 마친 다음에 나머지 인자와 함께 즉시 실행 가능한 함수 - currency 예제)

(커링 - f(a, b, c)처럼 단일 호출로 처리하는 함수를 f(a)(b)(c)와 같이 각각의 인수가 호출 가능한 프로세스로 호출된 후 병합되도록 변환하는 것입니다.)

## 3. 커링 하는 이유

- **매개변수**를 강제로 **매핑**할 수 있다.
- **순수함수**는 매개변수 하나만 갖는다. - 순수함수에 대한 이야기를 하면, 참조투명성, 함수형프로그래밍도 관련이 됨. 표현력이 좋아진다(!), 순수함수는 혼자 메모아이제이션도 할 수 있음.

    * repeatStar > repeatWith = (char) => { return (count) => }

## 4. Promise

자바스크립트는 어디에 쓰일까? 사용자들이 사용하는 브라우저에 쓰이고, 이는 결국 사용자 경험을 해치지 않는 것이 중요하다는 뜻이기도 하다. 그래서 자바스크립트는 비동기적으로 (요청을 보낸 후 응답에 관계 없이 다음 동작을 실행하는 것을 말함) 작동한다. 그렇지만 상황에 따라 동기적으로, 다시 말해 요청에 대한 응답을 받은 후 다음 동작을 실행해야하는 때가 있다. 

이전에는 "콜백"을 통해 문제를 해결했다. `fetchXXX` 함수의 인자로 콜백함수를 전달하고, 해당 fetch 함수의 맨 마지막에 해당 콜백함수를 실행시킴으로서 함수의 실행순서와 시점을 제어했다. 그렇지만, 이렇게 구현을 하는 경우, 콜백함수를 익명으로 전달하는 과정에서 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상이 일어난다. 

**Promise**는 Promise가 생성될 당시에는 알 수 없는 (정확하게 표현하자면, 꼭 알 수 있지는 않은) "특정 값"의 대리자(proxy) 역할을 한다. flutter에서 Future와 비슷하다고 보면 될 거 같다. 마치 어떤 요청에 대한 결과를 받는 것이 아니라, 요청을 상자 안에 넣어서 상자를 받는 것과 같은 것이다. 상자를 치워 두고 상자 안에 요청에 대한 결과가 생성 되었을 때 상자를 열어볼 수도 있고(이렇게 되는 경우 비동기적인 처리에 가까울 것이다), 상자를 받은 후 다른 것을 하지 않고 요청에 대한 결과가 생성될 때까지 기다렸다가 상자에서 결과를 꺼내볼 수도 있을 것이다. (이렇게 되는 경우 동기적인 처리가 될 것이다.) 그리고, 이 상자는 상자를 열었을 때의 결과를 바탕으로 어떤 액션을 취할 수 있도록 도와주는 역할을 하기도 한다. 비동기 연산이 종료된 후, 결과 값이나 실패 이유를 처리하기 위한 handler를 연결할 수 있도록 한다. Promise는 "pending", "fulfilled", "rejected" 총 세 가지 상태를 가지고 있다. 아직 결과가 나오지 않아 상자를 열어볼 수 없는 상태를 pending이라고 할 것이다. 그리고, 상자를 열어봤을 때 우리가 원하는 결과가 있는 경우는 "fulfilled" 상태일 것이며, 원하는 결과가 없는 경우는 "rejected" 상태일 것이다. Promise를 쓸 때 다음과 같은 형태로 사용할 수 있으며, Promise를 사용할 때 콜백지옥의 문제를 해결할 수 있는 것을 확인할 수 있다.

```jsx
userInfo()
	.then((info) => {
		return userAddress();
	})
	.then((address) => {
		return isSeoulUser();
	});
```

그리고 최근에 ES6에서 제공해주는 async, await 문법은 Promise의 사용을 더욱 간결하게 만들어줬다. async가 붙은 함수는 무조건 Promise를 반환한다. 프라미스가 아닌 값을 반환하더라도 해당 값을 프라미스(resolved promise)로 값을 감싸 이행된 프라미스가 반환되도록 한다. await를 사용하는 경우, 프라미스가 처리(settled)될 때까지 기다리며 결과는 그 이후에 반환된다.

## 5. RESTful API란?

**REST(REpresentational State Transfer)란, "웹에 존재하는 모든 자원(이미지, 동영상, DB 자원)에 고유한 URI를 부여해 활용"**하는 것으로, 자원을 정의하고 자원에 대한 주소를 지정하는 **방법론**을 의미한다고 한다. 따라서 RESTful API는 REST 특징을 지키면서 API를 제공하는 것을 의미한다.

## 6. HTTP 관련

1) **POST** : 정보를 입력하기위해 사용(Create)

2) **GET** : 정보를 요청하기위해 사용(Read)

3) **PUT** : 정보를 업데이트하기위해 사용(Update)

4) **DELETE** : 정보를 삭제하기위해 사용(Delete)