200916_TIL
===

일일회고
---
* 건강관리 해야겠다.

코어자바스크립트 정리
---

## Chapter 12. 제너레이터와 비동기 이터레이션

### 12.1. 제너레이터
* 개념 정리
    * generator 함수는 generator 객체를 반환한다. `next` 메서드를 사용할 때 제너레이터 객체가 반환되는데, 해당 객체는 value, done 두가지 프로퍼티를 갖는다.
    * generator는 iterable이다. `for...of` 등의 반복문을 사용할 수 있다.
    * generator composition: 제너레이터 안에 제너레이터를 넣는것. `yield*`를 사용해야함.
    * generator 안밖으로 정보 교환하기가 가능하다 (`yield`를 통해서!)
    * generator.throw: `yield` 안으로 에러를 보내고 싶을 때
* 질문과 답
    * 질문: 제너레이터를 사용할 때 얻을 수 있는 장점을 한가지 이야기해보세요
    * 답: 안밖으로 정보 교환이 가능하다

### 12.2. async 이터레이터와 제너리에터
* 질문과 답
    * 질문: 이터레이터와 async 이터레이터의 차이는?
    * 답: iterable을 반환하는 메서드는 각각 Symbol.iterator / Symbol.asyncIterator 이고, async 이터레이터는 일반 이터레이터와 다르게 "Promise"를 반환한다.

## Chapter 13. 모듈

### 13.1. 모듈 소개
* 질문과 답
    * 질문: webpack 과 같은 빌드 툴의 역할은 무엇이 있을까요?
    * 답: 집입점 역할을 할 모듈을 선택하고, 모듈간의 의존관계를 파악하여 모듈 전체를 한데로 모아 하나의 파일을 생성한다. 이런 과정에서 변형이나 최적화도 실행된다.

### 13.2. 모듈 내보내고 가져오기
* 질문과 답
    * 질문: 모듈에서 무언가를 가져오고 싶을 때, `import * as <obj>`를 써서 통째로 가져오기 보다는 `import {...}` 를 사용해서 가져올 대상을 명시하는 것이 좋습니다. 왜그럴까요?
    * 답: 빌드툴에서 필요없는 애들은 최종 산출물에 넣지 않을 수 있음. 어떤 걸 가져올지 명시하면 이름을 간결하게 만들 수 있음. 어디에서 무엇이 쓰이는지 알 수 있기 때문에 코드 구조를 파악하기 쉬워 리팩터링 하거나 유지보수에 도움이 됨.

### 13.3. 동적으로 모듈 가져오기
* 질문과 답
    * 질문: `import`를 사용하여 모듈을 동적으로 가져올 수 있을까요? 동적으로 가져오려면 어떻게 해야할까요?

## Chapter 14. 기타

### 14.1. Proxy와 Reflect 
* 개념 정리
    * Proxy: 읽기, 쓰기 등의 객체에 가해지는 값을 중간에 가로채는 객체
    * target: 감싸게 될 객체 / handler: 동작을 가로채는 메서드 (트랩)
        * get 트랩 - property 기본값 설정할 때 사용함
        * set 트랩 - 프로퍼티 값 검증할 때 사용함
        * ownKeys, getOwnPropertyDescriptor 트랩 - 프로퍼티의 목록 받아올 때 사용
        * deleteProperty 트랩 - 다른 트랩과 함께 사용했을 때 프로퍼티를 보호할 수 있음
        * has 트랩 - in 호출을 가로채서 범위 내 여부 확인 가능함
        * apply 트랩 - 
    * Reflect: Proxy를 더 쉽게 만들 수 있도록 함
    * Proxy 한계가 있음 
    * Proxy.revocable: `revoke` 사용하면 더 이상 동작안함

* 질문과 답
    * 질문: proxy의 역할은 무엇이며, proxy의 trap이란 무엇인가요?
    * 답: proxy는 객체의 wrapper역할을 하고, 해당 객체에 대한 읽기 쓰기 등의 작업을 중간에 가로채서 자체적으로 정의할 수 있도록 한다. 이 때, 동작을 가로채는 메서드를 trap이라고 한다.

### 14.2. Eval: 문자열 코드 실행하기
* 질문과 답
    * 질문: 과거에 `eval`을 사용했던 이유는 무엇이며, 왜 이제는 사용하지 않도록 권장하는걸까요?
    * 답: 이전에는 eval을 사용해야만 처리할 수 있는 것들이 많았지만, 현재는 외부 변수에 잘못접근하는 경우가 생길 수 있기 떄문에 사용하지 않는다. 웹팩 등을 사용하면 빌드를 했을 때 굉장히 간단한 변수명으로 바뀔 수 있는데, 이 때 eval 안에서 이러한 변수명에 접근하는 것이 가능하다. 이러한 위험때문에 eval 내부코드에서는 접근할 가능성이 있는 변수들은 이름을 바꾸지 않고, 이는 코드의 압축률에 안좋은 영향을 준다.

### 14.3. 커링
* 개념 정리
    * 커링: 단일 호출로 처리하는 함수를 각각의 인수가 호출 가능한 프로세스로 호출된 후, 병합되도록 변환 한 것을 의미한다. 커링은 "변환" 그 자체를 의미한다.
    * 커링을 사용해야 하는 이유
        * 매개변수를 강제로 매핑할 수 있다.
        * 순수함수는 매개변수 하나만 갖는다. - 순수함수에 대한 이야기를 하면, 참조투명성, 함수형프로그래밍도 관련이 됨. 표현력이 좋아진다(!), 순수함수는 혼자 메모아이제이션도 할 수 있음.
        * partial 함수를 쉽게 작성할 수 있다.
    * 고급 커리 구현

* 질문과 답
    * 질문: 커링이란 무엇이며, 함수를 커링한 경우 어떤 장점이 있을까요?
    * 답: 커링이란, 단일 호출로 여러개의 인자를 받는 함수를 분리하여, 인자별로 하나씩 호출되도록 하고 이 것이 병합되도록 변환하는 것을 의미한다. 커링을 사용하면 partial 함수를 구현할 수 있고, 함수형 프로그래밍 기법에 맞게끔 매겨변수를 하나로 갖는 순수함수를 만들 수 있는 등의 장점이 있다.

### 14.4. 참조 타입
* 질문과 답
    * 자바스크립트의 "참조 타입"이란 무엇인가요?

### 14.5. BigInt
* 질문과 답
    * 질문: BigInt란 무엇인지 설명하고, BitInt의 연산의 결과는 어떤 타입인지 말해주세요.
    * 답: BitInt란 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형이며, BitInt의 연산 값은 항상 BitInt 형으로 반환된다.


