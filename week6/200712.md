200712_TIL
===

6주차 피드백 강의 정리
---

* **RestaurantPage Test 작성**

    우선 a 태그 있는 지 확인하는 테스트 작성한다. 이 때, dispatch는 글로벌하게 선언하고, beforeEach를 사용하여 mockClear를 한다. (dispatch가 어떤 순서로 실행될지도 모르고 어떤 상태로 남아있는지 모르기 때문에, clear를 확실하게 해주는 것이 좋다)

* **RestaurantContainer**

    RestaurantContainer에 가서 a 태그로 구현해보고, 다시 바로 Link를 사용하여 구현함.

* **RestaurantsContainer Test**

    테스트가 깨지니까 Memory Router를 설정해주자. ```RestaurantPage```에서도 줄줄이 Memory Router를 설정해줘야 함.
    
    이렇게 하면, 귀찮으니까 다른 방법을 한 번 사용해보자. Link를 사용하지 않고 RestaurantContainer에서 링크를 받는 방법도 있음.

    ```javascript
    // RestaurantsContainer.test
    const handleClick = jest.fn();

    const { container } = render((
      <RestaurantsContainer onClickRestaurant={handleClick} />
    ));
    ```

    ```javascript
    // RestaurantsContainer
    export default function RestaurantsContainer({ handleClick }) {
      const restaurants = useSelector(get('restaurants'));

      function handleClick(restaurant) {
        event.preventDefault();
        // 링크로 이동하는 것을 막아줌. 우리는 하나의 페이지에서 하는게 목표! 
        return (event) => {
          onClickRestaurant(restaurant);
        }
        // 고차함수 - 함수르 받거나 함수를 리턴하는 것 고차함수로 만듦  
      } 

      return (
        <ul>
          // ...
          <a href="/restaurants/1" onClick={(event) => handleClick(restaurant)}
            type=""
          >
            {restaurant.name}
          </button>  
        </ul>
      );
    }
    ```

    ```javascript
    // RestaurantsContainer
    export default function RestaurantsPage({ Link }) {
      const history = useHistory();

      function handleClickRestaurant(restaurant) {
        // TODO: 이동
        const url = `/restaurants/${restaurant.id}`;
        history.push(url);
      }
      return (
        <div>
          // ...
          <RestaurantContainer
            onClickRestaurant={handleClickRestaurant}
          />
        </div>
      );
    }
    ```

* **RestaurantPage 구현하기**
    
    ```javascript
    // RestaurantPage.test
    const params = { id: '1' };

    const { container } = render((
      <MemoryRouter initialEntries={['/restaurants/1']}>
        <RestaurantPage params={params}/>
      </MemoryRouter>
    ));
    //이니셜 엔트리는 앱에서는 가능 근데 안되니까 따로처리해야 하네...
    ```
    ```javascript
    export default function RestaurantPage({ params }) {
      const { id } = params || useParams();

      return (
        <div>
          //...
        </div>
      );
    }
    ```

    > 현재 구현의 포인트: 
    
    > RestuarantPage - React Router를 처리한다.
    
    > RestaurantContainer - React Router에 대하여 모른다. Redux에 대한 처리를 한다.
    
    > RestaurantDetail - redux를 모른다.

* **fetchRestaurant 구현하기**

    mocks도 구현해주기! 
    ```javascript
    export async function fetchRestaurant({ restaurantId }) {
      return {
        id: restaurantId,
        // TODO: ... 
      };
    }
    ```

* **```loadRestaurant``` action 구현하기**

* **로딩중 만들기**
    ```javascript
    export default function RestaurantContainer() {
      useEffect(() => {
        dispatch(loadRestaurant({restaurantId: id}));
      }, []);

      const restaurant = useSelector(get('restaurant'));

      if (!restaurant) {
        return (
          <p>Loading...</p>
        )
      }

      return (
        <RestaurantDetail restaurant={restaurant} />
      );
    }
    ```
    action도 바꿔주기
    ```javascript
    export function loadRestaurant({ restaurantId }) {
      return async (dispatch) => {
        dispatch(setRestaurant(null)); //지워지게 해서 loading 보이게 하기

        const restaurant = await fetchRestaurant({ restaurantId });

        dispatch(setRestaurant(restaurant));
      };
    }
    ```

* **MenuItems를 따로 만들고 테스트하기**

    MenuItems 테스트하는 방법 중 인상적이었던 부분은 아래와 같다!

    ```javascript
    context('without menu item', () => {
      it('renders no items message', () => {
        [[], null, undefined].forEach((menuItems) => {
          const { container } = render(
            <MenuItems menuItems={menuItems} />
          );

          expect(container).toHaveTextContent('메뉴가 없어요');
        });
      });
    });
    ```

---
**[배운 점]**

사실 가장 기억에 남는 것은, page, container, presentational component 를 나누는 기준이었다. 이제까지의 패턴과 다르게 이번 과제에서는 'Page'라는 개념이 생겨버렸고, Container컴포넌트 페이지 컴포넌트 일반 컴포넌트를 나누는 기준을 어떻게 잡으면 좋을지 혼란을 겪고 있었다. 그리고, 이번 피드백 강의에서는 각 컴포넌트가 단 하나의 역할만 맡을 수 있도록 분리하고 필요한 것을 props로 넘겨주는 것을 볼 수 있었다. 