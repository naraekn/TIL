200831_TIL
===

코어자바스크립트를 처음부터 끝까지 다 봤다. 이해한 내용도 있고, 이해하지 못한 내용도 있다. 우선 내가 이해한 내용들을 글로 옮겨보기로 했다. 그리고 글로 옮기는 과정에서 베껴쓰기보다는, 최대한 나의 생각과 상상력(?)을 덧붙여서 글을 적어보기로 했다. 

코어자바스크립트
---

## Chapter2. 실행컨텍스트

### 1. 실행컨텍스트란 무엇인가?

실행할 코드에 대한 환경정보를 저장하고 있는 객체이다. 그리고, 이 객체는 "Call Stack"에 실행한 순서대로 쌓아올린다고 한다. 실행 컨텍스트는 왜 중요할까? 내가 생각 했을 때 자바스크립트가 "실행 컨텍스트"를 저장해야만 하는 이유는, 자바스크립트의 코드가 (어쩌면 자바스크립트 뿐만 아니라) 코드 조각들은 하나의 실행 환경에만 영향을 받지 않기 때문이다. 만약, "함수" 혹은 "클래스"와 같은 것이 없다면, 다시 말해 global variable 만이 존재하는 곳에서 코드가 동작한다면 우리는 더 이상 실행하는 맥락을 신경쓸 필요 없을 것이다. 왜냐하면, 실행하는 맥락은 단 하나일 것이기 때문이다. (그 말은 다시 말해, "실행컨텍스트"라는 말조차 필요없다는 뜻이기도 하다.)

그렇지만, 우리는 코드 속에서 서로 다른 맥락들을 발견할 수 있다. global variable로 선언된 것도 있고, function 혹은 class로 선언된 local variable도 있을 것이다. 그리고 여기서 가장 중요한 것은, local environment와 global environment는 완전히 독립적으로 존재하는 것이 아니라, 서로에게 영향을 줄 수 있는 환경들이라는 점이다. 이전에 "참조 투명성"이라는 주제를 처음 들었을 때 흥미로웠던 이유는, 어쩌면 내가 너무나도 당연하게 생각하고 있던, local environment 와 global environment가 서로 영향을 주고 받을 수 있으며 그로 인한 위험성이 있다는 것을, 어쩌면 너무 당연하게만 여겼던 것을 다시 한 번 생각해줄 수 있게 해줬기 때문이다. 

자바스크립트가 우리가 원하는대로 동작하게 하기 위해서는 따라서, 각 코드들의 실행되는 환경을 저장해야만 하고, 각 실행 컨텍스트끼리의 관계를 정의해야 하며 컨텍스트들이 어떤 관계인지를 명확하게 해야할 필요가 있다. 어떤 관계인지 명확하게 한다는 것은, 어떤 실행컨텍스트는 또 다른 실행컨텍스트를 참고해도 되지만, 어떤 실행컨텍스트는 독립적으로 존재해야할 수도 있다는 것이다. 그래서 자바스크립트는 코드에 대한 환경정보인 "실행컨텍스트"를 정의하여 코드 실행시에 저장해놓고, 실행컨텍스트 내부에 다른 실행컨텍스트와의 관계를 정의하고 해당 컨텍스트에 대한 정보들 역시 저장해놓는다. 

### 2. 그렇다면, 실행컨텍스트에는 어떤 것이 저장되는가?

[우선 베껴쓰기 - 이정도는 외워야하지 않을까]
* **Variable Environment**: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언시점의 Lexical Environment 스냅샷을 가지고 있다.
* **Lexical Environment**: 처음에는 Variable Environment와 같지만 변경사항이 실시간으로 반영된다.
    * **environmentRecord**: 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. (`호이스팅` 관련됨!)
    * **outerEnvironmentReference**: 현재 호출된 함수가 선언될 당시의 Lexical Environment를 참조한다. 즉, 과거시점의 '선언될 당시'에 주목하자! (`스코프체인` 관련됨!)
* **thisBinding**: `this` 식별자가 바라봐야할 객체를 저장한다.

### 3. 호이스팅이란 무엇이며, environmentRecord와 무슨관계인가?

> Hoisting was thought up as a general way of thinking about how execution contexts (specifically the creation and execution phases) work in JavaScript. Instead, the variable and function declarations are put into memory during the compile phase, but stay exactly where you typed them in your code.

음.. MDN 문서를 봐도 모호하긴 하다. 그렇지만 우선 이해한대로 적어보자면 호이스팅이란 (책에 나온 그대로 적어보자면) "변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념"이라고 한다. 호오.. 

그럼, 이렇게 생각해보자. 우선 자바스크립트의 변수 정보를 수집하는 과정은 복잡할 것으로 예상할 수 있다. 호이스팅이라는 와닿지도 않는 단어로라도 설명하려고 노력하는거 보면(?) 아무튼 자바스트립트의 변수 수집 과정은 뭔가 헷갈릴 것이다. 그리고, 호이스팅을 통해 두 번째로 얻을 수 있는 두 번째 힌트는 밑에 있던 애들을 위로 끌어올려서 변수 정보를 미리 파악한다고 어렴풋이 짐작할 수도 있을 거 같다.

실제로 변수 정보를 수집하는 과정이 어떻게 되는지 살펴보기 이전에,environmentRecord와 호이스팅과의 관계에 대해서 생각해보기로 했다. 왜 environmentRecord는 호이스팅과 관련이 되는가? environmentRecord의 관심사는 "변수 정보"이기 때문이다. 현재 실행되는 컨텍스트의 대상 코드 내에 어떤 식별자가 있는지만 관심을 갖기 때문에, 이러한 식별자들만 효율적으로 알아차리면 되는 것이다. 어쩌면 environmentRecord가 모든 코드들을 일일히 살펴보고 관심을 갖기보다 자신이 원하는 것만 빠르게 알기위해 선택한 "변수 정보 수집 방법"을, 자바스크립트 엔진의 생각을 도무지 이해하기 힘든 인간이 아마도 호이스팅이라는 이름을 붙여서 사용하고 있는건지도 모르겠다. 

그렇다면, environmentRecord가 어떻게 현재 실행되는 컨텍스트 내 식별자를 파악하는가? (어떻게 호이스팅하는가?) 우선, 선언된 변수명과 함수 선언의 정보들을 수집한다. 여기서 헷갈리면 안되는 점은, 변수의 값 자체는 수집하지 않고, 변수 정보만 수집한다. 함수의 경우, 함수 선언문(function declaration)은 전체를 통째로 수집한다. 자바스크립트 엔진씨도 함수선언문을 만나면 당황스럽긴 했나보다. environmentRecord의 관심사는 "어떤 식별자가 있는가?"이기 때문에, 사실 변수가 저장하는 값보다 변수 그 자체에 관심을 갖는다. 그런데, 함수 선언의 경우 이를 식별할만한 무언가가 애매했나보다. 그 함수의 이름과 내용까지 하나로 봐서 그런건가. 아무튼, 함수 선언은 통째로 기억된다.

그리고 이렇게 미리 environmentRecord에 "호이스팅"된 식별자들이 어떤 형태이며 어떤 순서냐에 따라, 결국 코드의 실행도 영향을 받게 된다. 책에 나오는 예제들은 사람이 이해하기 쉽게 호이스팅 된 상태를 가정하고, 이에 따라 우리가 생각했던 코드의 실행 순서와 실제 코드의 실행순서가 다르다는 것을 지적해준다. 내가 생각했을 때 여기서의 핵심은, 인간은 알파벳으로 쓰여있는 코드를 마치 글을 읽듯이 차례대로 읽어나가고 우리가 이제까지 이해한대로 코드를 이해하지만, 실제 자바스크립트 엔진에 의해 실행되는 순서는 인간의 이해와는 사뭇 다를 수 있다는 것이다. (코드만 보고 있는 우리는 눈치채지 못했지만) 사실 자바스크립트 엔진은 어떤 코드를 실행하기 전에 "실행컨텍스트"라는 것을 구성하는 과정을 거치고, 이 실행컨텍스트를 기반으로 하여 내부 코드를 실행시킨다. 따라서, 우리의 눈에 보이는 순서가 실제 동작하는 과정과는 다를 수 있음을 언제나 인지해야 한다. 우리가 호이스팅이 헷갈리지만 알아야만 하는 이유는, 우리가 안타깝게도 자바스크립트 엔진처럼 코드를 바라볼 수 없기 때문인거같다. 

우리가 잘 알고있듯이, 자바스크립트에는 함수를 선언하는 두 가지 방식이 있다. 위에서 언급한 것은 "함수 선언문"이었지만, 이제 새롭게 이야기 해 볼 주제는 "함수표현식 (function expression)"이다. (보통, 함수 표현식은 익명함수표현식을 말하며, 변수에 함수를 할당하는 형태이다.) 그리고, 함수표현식도 결국 변수에 함수를 할당하는 형태이기 때문에, 함수 전체가 호이스팅 되는 것이 아니라 변수 선언부만 호이스팅 된다. 그리고, 이 책을 읽으면서 재밌었던 것 중 하나는, 극단적인 사례 하나를 대면서 함수선언문보다 함수표현식을 쓰는게 좋다! 라고 한다. 그런데, 몇 주 전에 읽은 모던자바스크립트에서는 함수선언물을 쓰기를 권장한다. (어쩌라는거지) 아직 뭐가 더 나은지는 잘 모르겠다. 누구말이 맞을까

### 4. 스코프체인이란 무엇이며, outerEnvironmentRecord와 무슨관계인가?

이제 1번에서 언급한 가장 핵심에 대해서 이야기해야할 때인 거 같다. 결국 자바스크립트 엔진이 실행컨텍스트를 저장하고 만들어야만 하는 이유는, 코드의 실행컨텍스트가 "하나"가 아니기 때문이고, 또 이러한 실행컨텍스트들이 서로 관계를 맺고있기 때문이라고 했다. 그럼 조금 더 디테일하게 들여다 볼 수 있을 거 같다. environmentRecord의 관심사인 "식별자"에 대해서 생각해보자. 한 실행 컨텍스트의 식별자는 하나의 컨텍스트에서만 유효한가? 아니면, 다른 컨텍스트와도 관계를 맺을 수 있을까? 

스코프란, 바로 이 식별자의 유효범위에 대한 이야기이다. 책의 말을 그대로 빌리자면, "어떤 경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근이 가능하지만, A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근할 수 있다". 이게 참, 이제까지 너무나도 당연하게 여기고 있던 것이 당연하게 느껴지지 않게 하는 말이다. 당연한 것들을 언어로 정제하고 나면, 당연하지 않음을 그 때서야 다시 깨닫게 되기도 하는 거 같다. 이제까지 당연하게 함수의 내부에서는 전역변수를 가져다 쓸 수 있지만, 함수의 외부에서는 함수 내에 정의된 변수를 가져다 쓰지 못한다는 것을 인지하고 코딩을 해왔다. 그런데, 이게 당연하지 않을 수 있다는 것이다. 

자바스크립트에서 스코프 (식별자의 유효범위)는 오직 함수에 의해서만 생성된다. 이러한 식별자의 유효점위를 안에서부터 바깥으로 검색해나가는 것을 스코프체인이라고 한다. 다시 말하자면, 어떠한 식별자의 유효범위 (스코프)에 따라 하나의 실행컨텍스트에서 사용할 수 있는 식별자들이 달라진다. 현재 실행되고 있는 컨텍스트에서 먼저 사용하고자 하는 식별자를 검색하지만, 없는 경우 스코프체인을 타고 사용할 수 있는 식별자를 검색해나가며 무조건 스코프체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하도록 되어있다. 즉, 생각해보면 전역 컨텍스트에서 지역 컨텍스트로 갈 수록 규모는 작아지지만 스코프체인을 타고 접근 가능한 변수는 늘어나게 되어있는 것이다.

그래서!! outerEnvironmentRecord는 뭘하냐.. 위에서도 정리했듯이 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조하고 있다. 그리고 이러한 스코프체인을 따라 식별자들을 안에서부터 바깥으로 차례대로 검색하는 것이 가능한 이유는, 바로 outerEnvironmentRecord가 외부에 있는 실행컨텍스트의 LexicalEnvironement를 참조하고 있기 때문이다.

## Chapter3. this

우선 시작하기 전에 드는 생각은, 나는 javascript의 `this`가 싫다.

### 1. this란 무엇인가
this의 용법에 대해서 먼저 생각해보기에는 내가 너무 헷갈리고 (하기싫어서), 그건 두 번째로 미뤄두기로 하자. this의 사용처에 대해 궁금해하기전에, 나는 this가 왜 있어야만 하는가에 대해서 생각해보고 싶다. 사실 책에도 명확하게 "this의 존재이유는 이겁니다!"라고 정리해주지는 않는 거 같다. 그렇다면, 나는 또 책에서 던져주는 힌트들을 조합해서 추측할 수 밖에 없는 거 같다.

힌트1) this는 실행컨텍스트가 생성될 때 함께 결정된다. 
힌트2) this는 어떤 대상을 가르키고 있다. 
힌트3) 상황에 따라 this가 가르키는 대상이 다르기도 하다.
힌트4) 실행 컨텍스트 활성화 당시에 this가 지정되지 않은 경우 this에는 전역객체가 저장된다.

이렇게 힌트 4개를 정리했는데도 모르겠다. 그렇다면, 결국 귀납적으로 접근을 하는 수밖에 없을 듯하다. 우선 모든 힌트들을 다 끌어모으고, 그걸 바탕으로 this의 필요에 대하여 다시 생각해봐야겠다.

### 2. this는 언제 쓸 수 있는가

(여기부터는 내일)


---

### [느낀점]

1. 왜 남들이 정리해 놓은 것을 그대로 읽거나 베껴쓰면 이해가 안되는데, 정답일지 아닐지도 모르는 내 생각들을 연결짓고 덧붙이면 이상하게 더 잘 이해가 잘되는 거 같다. 공부를 할 때 상상력은 꽤 쓸모있는 거 같기도 하다.
2. 왜 벌써 두시지 나머지는 내일 더 생각해보기