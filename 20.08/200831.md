200831_TIL
===

코어자바스크립트를 처음부터 끝까지 다 봤다. 이해한 내용도 있고, 이해하지 못한 내용도 있다. 우선 내가 이해한 내용들을 글로 옮겨보기로 했다. 그리고 글로 옮기는 과정에서 베껴쓰기보다는, 최대한 나의 생각과 상상력(?)을 덧붙여서 글을 적어보기로 했다. 

코어자바스크립트 Chapter2. 실행컨텍스트
---

### 1. 실행컨텍스트란 무엇인가?

실행할 코드에 대한 환경정보를 저장하고 있는 객체이다. 그리고, 이 객체는 "Call Stack"에 실행한 순서대로 쌓아올린다고 한다. 실행 컨텍스트는 왜 중요할까? 내가 생각 했을 때 자바스크립트가 "실행 컨텍스트"를 저장해야만 하는 이유는, 자바스크립트의 코드가 (어쩌면 자바스크립트 뿐만 아니라) 코드 조각들은 하나의 실행 환경에만 영향을 받지 않기 때문이다. 만약, "함수" 혹은 "클래스"와 같은 것이 없다면, 다시 말해 global variable 만이 존재하는 곳에서 코드가 동작한다면 우리는 더 이상 실행하는 맥락을 신경쓸 필요 없을 것이다. 왜냐하면, 실행하는 맥락은 단 하나일 것이기 때문이다. (그 말은 다시 말해, "실행컨텍스트"라는 말조차 필요없다는 뜻이기도 하다.)

그렇지만, 우리는 코드 속에서 서로 다른 맥락들을 발견할 수 있다. global variable로 선언된 것도 있고, function 혹은 class로 선언된 local variable도 있을 것이다. 그리고 여기서 가장 중요한 것은, local environment와 global environment는 완전히 독립적으로 존재하는 것이 아니라, 서로에게 영향을 줄 수 있는 환경들이라는 점이다. 이전에 "참조 투명성"이라는 주제를 처음 들었을 때 흥미로웠던 이유는, 어쩌면 내가 너무나도 당연하게 생각하고 있던, local environment 와 global environment가 서로 영향을 주고 받을 수 있으며 그로 인한 위험성이 있다는 것을, 어쩌면 너무 당연하게만 여겼던 것을 다시 한 번 생각해줄 수 있게 해줬기 때문이다. 

자바스크립트가 우리가 원하는대로 동작하게 하기 위해서는 따라서, 각 코드들의 실행되는 환경을 저장해야만 하고, 각 실행 컨텍스트끼리의 관계를 정의해야 하며 컨텍스트들이 어떤 관계인지를 명확하게 해야할 필요가 있다. 어떤 관계인지 명확하게 한다는 것은, 어떤 실행컨텍스트는 또 다른 실행컨텍스트를 참고해도 되지만, 어떤 실행컨텍스트는 독립적으로 존재해야할 수도 있다는 것이다. 그래서 자바스크립트는 코드에 대한 환경정보인 "실행컨텍스트"를 정의하여 코드 실행시에 저장해놓고, 실행컨텍스트 내부에 다른 실행컨텍스트와의 관계를 정의하고 해당 컨텍스트에 대한 정보들 역시 저장해놓는다. 

### 2. 그렇다면, 실행컨텍스트에는 어떤 것이 저장되는가?

[우선 베껴쓰기 - 이정도는 외워야하지 않을까]
* **Variable Environment**: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언시점의 Lexical Environment 스냅샷을 가지고 있다.
* **Lexical Environment**: 처음에는 Variable Environment와 같지만 변경사항이 실시간으로 반영된다.
    * **environmentRecord**: 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다. (`호이스팅` 관련됨!)
    * **outerEnvironmentReference**: 현재 호출된 함수가 선언될 당시의 Lexical Environment를 참조한다. 즉, 과거시점의 '선언될 당시'에 주목하자! (`스코프체인` 관련됨!)
* **thisBinding**: `this` 식별자가 바라봐야할 객체를 저장한다.

### 3. 호이스팅이란 무엇이며, environmentRecord와 무슨관계인가?

> Hoisting was thought up as a general way of thinking about how execution contexts (specifically the creation and execution phases) work in JavaScript. Instead, the variable and function declarations are put into memory during the compile phase, but stay exactly where you typed them in your code.

음.. MDN 문서를 봐도 모호하긴 하다. 그렇지만 우선 이해한대로 적어보자면 호이스팅이란 (책에 나온 그대로 적어보자면) "변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념"이라고 한다. 호오.. 

그럼, 이렇게 생각해보자. 우선 자바스크립트의 변수 정보를 수집하는 과정은 복잡할 것으로 예상할 수 있다. 호이스팅이라는 와닿지도 않는 단어로라도 설명하려고 노력하는거 보면(?) 아무튼 자바스트립트의 변수 수집 과정은 뭔가 헷갈릴 것이다. 그리고, 호이스팅을 통해 두 번째로 얻을 수 있는 두 번째 힌트는 밑에 있던 애들을 위로 끌어올려서 변수 정보를 미리 파악한다고 어렴풋이 짐작할 수도 있을 거 같다.

실제로 변수 정보를 수집하는 과정이 어떻게 되는지 살펴보기 이전에,environmentRecord와 호이스팅과의 관계에 대해서 생각해보기로 했다. 왜 environmentRecord는 호이스팅과 관련이 되는가? environmentRecord의 관심사는 "변수 정보"이기 때문이다. 현재 실행되는 컨텍스트의 대상 코드 내에 어떤 식별자가 있는지만 관심을 갖기 때문에, 이러한 식별자들만 효율적으로 알아차리면 되는 것이다. 어쩌면 environmentRecord가 모든 코드들을 일일히 살펴보고 관심을 갖기보다 자신이 원하는 것만 빠르게 알기위해 선택한 "변수 정보 수집 방법"을, 자바스크립트 엔진의 생각을 도무지 이해하기 힘든 인간이 아마도 호이스팅이라는 이름을 붙여서 사용하고 있는건지도 모르겠다. 

그렇다면, environmentRecord가 어떻게 현재 실행되는 컨텍스트 내 식별자를 파악하는가? (어떻게 호이스팅하는가?) 우선, 선언된 변수명과 함수 선언의 정보들을 수집한다. 여기서 헷갈리면 안되는 점은, 변수의 값 자체는 수집하지 않고, 변수 정보만 수집한다. 함수의 경우, 함수 선언문(function declaration)은 전체를 통째로 수집한다. 자바스크립트 엔진씨도 함수선언문을 만나면 당황스럽긴 했나보다. environmentRecord의 관심사는 "어떤 식별자가 있는가?"이기 때문에, 사실 변수가 저장하는 값보다 변수 그 자체에 관심을 갖는다. 그런데, 함수 선언의 경우 이를 식별할만한 무언가가 애매했나보다. 그 함수의 이름과 내용까지 하나로 봐서 그런건가. 아무튼, 함수 선언은 통째로 기억된다.

---

### [느낀점]

1. 왜 남들이 정리해 놓은 것을 그대로 읽거나 베껴쓰면 이해가 안되는데, 정답일지 아닐지도 모르는 내 생각들을 연결짓고 덧붙이면 이상하게 더 잘 이해가 잘되는 거 같다. 공부를 할 때 상상력은 꽤 쓸모있는 거 같기도 하다.
2. 이거 챕터7까지 오늘안에 다하고 잘 수 있을지 의문이다. 왜 벌써 열한시반이지