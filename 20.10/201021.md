201021_TIL
===

일일 회고 (모던자바스크립트 스터디 회고)
---

오늘은 총 10주간의 모던자바스크립트 스터디가 끝났다. 오늘 일일 회고는 모던자바스크립트 스터디를 통해 내가 무엇을 얻었는지, 또 앞으로 어떻게 해야할지에 대해서 정리하며 고민해봐야겠다.

### 나는 무엇을 얻었는가?

1. **좌절감과 극복방법에 대한 고민**

    우선, 좌절감이라는 감정을 얻게 되었다. 스터디를 하면 사람들이 이런부분은 흥미로웠고 재밌었다고 이야기를 했지만, 사실 나는 "재밌다"거나 "흥미를 느낀" 부분이 많지 않았다. 사실 어떤 지식에 대한 흥미와 지식은 내가 알고 있고 경험한것과 접점이 있을 때 발생하고, 더 나아가 궁금한 점이나 질문 역시 그 지식에 대한 고민을 해본 사람만이 할 수 있기 때문이다. 
    
    2,3장으로 갈 수록 생소한 내용들이 많았고, 생소할 수록 어디에 무게를 두고 공부해야할지 모르겠고 이해를 하고 넘어가는 시간도 오래 걸렸다. 그렇기 때문에 내가 "이해하고 있다"는 자신감을 가지고 대답할 수 있는 질문들은 많지 않았다. 모르는 건 많은데 공부해야 할 것은 많다는 것에서 좌절감을 느꼈고, 각 직업마다 극복해야할 어려움은 다르겠지만 개발자라는 직업이 일을 하며 마주해야할 어려움이 이런 "모르는 것"으로부터 온다는 사실 자체에서 온다는 것에 더 좌절감이 들었던 거 같다. 그래서, 스터디 끝에는 마음의 짐을(??) 얻어갔던 거 같다.

    앞으로 내가 개발을 한다면 이러한 좌절감을 계속 마주하게 될 것이고, 그렇기 때문에 이러한 감정에 대한 극복방법은 필요하다는 생각이 들었다. 고민에 대한 결론은 사실 단순했다. 좌절감 느낄 필요가 없고 조급해하지 말고 할 수 있는 것들을 하는 것이다. 누군가의 지식은 그 사람의 경험과 맥락을 고려해야하기 때문에, 나의 맥락에서는 그 지식을 모르는 것이 당연함을 인정하고 뻔뻔해질(?) 필요는 있곘다는 생각이 들었다. 개발을 10년한 사람들끼리 대화를 하는 곳에 1년차가 껴있어서 좌절감을 느껴야할 이유가 없는 것처럼 말이다. 그저 꾸준하지만 조급하지 않게 할 수 있는 것들을 하는 것이 내가 할 수 있는 것이라는 생각이 들었다.

2. **자바스크립트에 대한 첫 번째 지식**

    스터디를 시작하기 전까지는 코드숨을 하며 익힌 것들이 내가 아는 javascript에 대한 전부였는데, 지난 10주간 모던자바스크립트를 읽으며 자바스크립트에 대하여 폭넓게 이해할 수 있었다. 처음에는 지금 내 수준에서 해야하는 것보다 더 많은게 아닐까라는 생각이 들었지만, 지나고 보니 어려웠지만 내가 앞으로 사용할 언어의 좋은 시작점을 제공해줬다는 점에서 좋았다는 생각이 들었다. 이전에 개발을 하며 내가 사용하는 언어에 대해서 얕은 이해만 가지고 개발을 했을 때 느꼈던 답답함을 여전히 javascript를 사용하면서도 느끼겠지만 적어도 좋은 시작점을 얻었고 내가 모르는 것이 있다면 돌아와서 찾아볼 곳이 생겼다는 점에서는 좋다는 생각이 들었다.
    
3. **배운 것을 활용하기**

    지금 돌아보니 스터디를 통해 배운 것을 다양한 곳에 써먹었다는 사실을 알게 되었다.
    
    먼저, 지나가면서 매일 알고리즘 문제풀이를 해야한다는 이야기를 듣고 혁준님과 매일 알고리즘 문제풀이를 하고 인증하는 것을 시작하게 됐다. 아직 시작한지 열흘밖에 안되긴했지만, 열흘간의 꾸준함으로도 javascript에 대한 이해도 더 생겼고, 알고리즘에 대해서도 더 이해하게 됐고, 코딩테스트와 상관없이 왜 매일 알고리즘 문제풀이를 해야하는지에 대한 고민까지 해보게 되었다.

    또, 여러번 커링의 예시를 보여주셔서 처음에는 이해하기 어렵기만 했던 커링을 나도 적용해볼 수 있게 됐다. (적절하게 사용했는지는 모르겠다.) 알고리즘 문제풀이를 어떤 날은 답을 통과시키는 것보다 "좋은 표현"을 사용하는데 집중해서 문제를 풀었는데, 그 날 내가 사용했던 코드에는 커링을 사용해볼 수 있겠다는 생각이 들었다. 스터디에서 이야기할 때는 와닿지 않던 커링의 장점에 대해서 다시 한 번 생각해볼 수 있었다.

    그 외에도 면접에도 도움이 많이 됐고 내가 따로 공부를 해나가고 있는 것에도 도움이 되었다는 생각이 들었다. 막상 지나올 때는 "도움이 됐나?"에 대해서 생각해볼 겨를이 업었는데, 이제 돌아보니 꽤 유용하게 배운 것을 사용하고 있다는 생각이 들어서 좋았다.

4. **유용한 학습 방법**

    친구들에게 언제 한 번 스터디 방식에 대해서 이야기를 해준적이 있는데, "질문을 만들어서 서로에게 질문하고 답하는 방식으로 진행한다"라고 하면 친구들은 살벌한(?) 방법이라고 반응했다. 내가 생각해도 이러한 스터디 방식이 쉬운 방법은 아니라고 생각한다. 우선, 한 개의 스터디를 위해 투자해야하는 시간이 굉장히 많이 들어간다. 스터디 범위 자체도 적지 않을 뿐더러, 질문을 만들고 답을 생각하는 시간도 필요했다. 또, 체력(?)적으로도 피곤하다. 적절한 질문을 만들기 위하여, (공부 안하면 질문도 못만든다) 엄청나게 집중을 해야했다. 
    
    그렇지만, 이러한 방식 덕분에 혼자 했다면 안했을 공부들을 할 수 있었던 거 같다. 누군가의 질문에 대답하기 위해서는, 억지로라도 더 공부를 해야했고 이 방법은 괴롭지만 효과적인 편이었다. 공부도 핵심을 더 깊이있게 할 수 있었던 거 같다. 평소 같았으면 경중을 따지지 않고 지나갔을 내용들을, 내 수준 안에서의 내용의 중요도를 매기고 또 중요하게 생각한 것에 대하여 한 번 더 공부하게 되었던 효과도 있었다. 
    
    물론 배경이 없는 지식에 대한 공부의 방법으로는 누군가에게는 버거운 방법일 수도 있겠지만, 공부를 하는 주제에 대해서 어느 정도의 관심과 필요를 느끼는 사람에게는 효과적인 거 같다. 특히, 모던자바스크립트 스터디보다 운영체제를 공부할 때 이러한 공부 방법이 굉장히 효과적이었다. 학교에서 배운 적이 있어서 적절한 배경지식과 관심이 있었고, 공부를 함께 하는 사람들의 지식의 수준과 목표가 비슷했으며, 모던자바스크립트 스터디보다 서로에게 질문을 더 적극적으로 던졌으며, 대답해야한다는 부담감은 컸으나 대답하지 못한 질문들에 대한 좌절감은 적었다. 이러한 조건들이 갖춰줬을 때 질문을 만드는 방법이 제일 효과적으로 적용되었던 거 같다. 

    그리고 이러한 학습 방법의 핵심은 결국 사람들과 함께 하는 것이라는 것도 생각해보게 되었다. 항상 공부는 혼자 해왔는데 같이 하는 공부가 더 효과적이라는 것을 이번에 많이 느꼈고, 함께 하는 사람들을 통해 배우는 것들이 많아서 좋았던 거 같다. 앞으로도 공부는 혼자 하기보다 사람들과 함께 해야겠다는 생각을 갖게 됐다.


### 나는 앞으로 어떻게 할 것인가?

1. 평소에 지식을 설명하는 습관을 가져야겠다.

    운영체제, 네트워크, 모던자바스크립트 스터디를 하면서 느끼는 것의 공통점은, 내가 지식을 설명하는데 부족함이 많다는 것이었다. 나는 주어진 지식에 대한 의문을 던지고 의문을 해결하는 과정은 좋아하는 거 같다. 그렇지만 그 지식을 곱씹어보고 내 것이 될 정도까지 공부하는 것은 별로 좋아하지 않는다는 것을 깨달았다. 그렇지만 결국 이 문제는 내가 해결해야할 문제라는 생각이 들었다. 

    그래서, 평소에 내가 설명하는 연습을 언제 어떤 방법으로 해야 효과적으로 할 수 있을지에 대해서 생각해봤다. 특별히 시간을 따로 빼기보다 그냥 지나가는 시간들을 활용하기로 했다. 평소에 산책을 하거나 이동을 할 때 생각을 정리하는 것을 좋아하는데, 생각의 주제 중 하나로 내가 얻게 된 지식을 넣어 봐야겠다는 생각이 들었다. 앞으로 출퇴근을 하게 되면 길 위에서 버려지는 시간이 많을 텐데, 내가 얻게 된 지식을 어디까지 알고 어디까지를 모르는지 이동하면서 고민해보는 것만으로도 큰 공부가 되겠다는 생각이 들었다. 또, 내가 안다고 생각했지만 모르는 것이 있다면 그냥 핸드폰으로라도 짧게 찾아보는 것만으로도 도움이 될 거 같다. 이건 이번주부터 조금씩 천천히 실천을 해봐야겠다. 

2. 시간에 대한 우선순위를 정해야겠다. 

    이제 회사를 다니면 가용시간이 줄어들기 때문에 내가 쓸 수 있는 시간을 최대한 활용해서 공부를 하되, 이 안에서 우선순위를 정확하게 나눠야겠다는 생각이 들었다. 지금 할 수 있는 것들을 모두 다 할 수 없고, 모든 것의 우선순위가 같지 않기 때문에 나에게 필요한 공부와 미뤄도 되는 공부를 조금은 구분할 필요가 있다는 생각이 들었다. 무조건 많이 한다고 좋은 것이 아니기 때문에, 우선순위의 가지를 쳐내는 것에 대하여 고민해봐야겠다. 

처음으로 스터디를 완주해서 그 과정들을 돌아보다보니 오랜만에 길게 일일 회고를 쓰게 됐다. 이제 알고리즘 문제풀이를 하러가야겠다. 오늘은 정규표현식을 써먹을 수 있는 문제를 하나 풀고 자야겠다. 

<br>
<br>

스터디 준비
---

4. 브라우저에 데이터 저장하기
* 4.1. 쿠키
    * 내용정리
        * 쿠키는 브라우저에 저장되는 작은 크기의 문자열로, HTTP 프로토콜의 일부임.
        * 세션 쿠키: expires(유효 일자)나 max-age(만료 기간) 옵션이 지정되어있지 않아, 브라우저가 닫힐 때 삭제되는 쿠키
        * 서드파티쿠키: 사용자가 방문 중인 도메인이 아닌 다른 도메인에서 설정한 쿠키를 "서드 파티 쿠키(third-party cookie)"라고 부름.
    * 세션쿠키란 무엇인가요?
    * expires(유효 일자)나 max-age(만료 기간) 옵션이 지정되어있지 않아, 브라우저가 닫힐 때 삭제되는 쿠키
* 4.2. localStorage와 sessionStorage
    * localStorage와 sessionStorage의 차이는?
    * localStorage: 오리진이 같은 탭, 창 전체에서 공유되며, 브라우저를 껐다 켜도 남아있음.
    * sessionStorage: 오리진이 같은 브라우저 탭, iframe에서 공유되며, 페이지를 새로 고침 해도 남아있으나, 하지만 탭이나 브라우저를 종료하면 사라짐.
* 4.3. IndexedDB
    * localStorage와 비교했을 때 IndexedDB가 갖는 장점은?
    * 더 많이 저장할 수 있다. (용량제한 없으나 하드웨어나 브라우저 상태에 따라 다름) String아닌 자바스크립트 어떤 형태든 저장가능.
    * 대용량인경우에만

5. Animation
* 5.1. 베지어 곡선
    * 베이어 곡선의 장점은?
    * 제어점을 마우스로 움직이면서 선을 부드럽게 그릴 수 있습니다.
    * 복잡한 도형은 몇 개의 베지어 곡선(Bezier curves)으로 만들 수 있습니다.
* 5.2. CSS 애니메이션
    * javascript과 비교했을 때 CSS로 애니메이션을 구현하는 것의 장점은?
    * 쉽고 간단하게 구현할 수 있음. (javascript는 비교적 더 할 수 있는 범위가 많은 property 변경, 새로운 요소 추가 등)
* 5.3. JavaScript animations
    * requestAnimationFrame의 역할은?
    *  브라우저에게 수행하기를 원하는 애니메이션을 알리고 다음 리페인트가 진행되기 전에 해당 애니메이션을 업데이트하는 함수를 호출한다. 이 메소드는 리페인트 이전에 실행할 콜백을 인자로 받는다.

6. 웹 컴포넌트
* 6.1. 궤도의 높이에서
   * 컴포넌트의 조건은?
   * 고유한 자바스크립트 클래스, 외부코드가 접근할 수 없으며 해당 클래스에서만 관리되는 DOM 구조(‘캡슐화’ 원칙), 구성요소에 적용되는 CSS 스타일, 다른 구성요소와 상호작용하기 위한 이벤트, 클래스, 메서드 등을 일컫는 API
* 6.2. Custom elements
   * custom element를 등록하는 메서드는?
   * `customElements.define`
* 6.3. Shadow DOM
    * Shadow DOM이란 무엇이며 언제 사용하는가?
    * 섀도 DOM은 DOM의 구조를 가지고 있으나 외부에는 노출되지 않은 DOM을 말하며 DOM의 구조를 캡슐화할 때 사용한다.
    * 참고: https://d2.naver.com/helloworld/188655
* 6.4. Template element
    * template 요소의 역할은 무엇이고, 사용하려면 어떻게 해야할까요?
    * 기본 <template>제공 요소는 HTML 마크 업 템플릿의 저장소 역할을합니다. 브라우저는 내용을 무시하고 구문 유효성 만 확인하지만 JavaScript에서 액세스하고 사용하여 다른 요소를 만들 수 있습니다.
* 6.5. Shadow DOM slots, composition
    * custom element를 shadow dom으로 옮겼을 때, CSS 스타일이 적용되지 않습니다. 이 문제를 어떻게 해결할까요?
    * shadow dom은 <slot>을 지원하며 light dom으로부터 내용이 채워진다.
* 6.6. Shadow DOM styling
    * ShadowDOM 여부와 상관없이 CSS를 적용하고 싶은 경우 어떻게 해야할까?
    * CSS custom properties를 사용한다.
* 6.7. Shadow DOM and events
    * ShadowDOM의 경계를 넘어 이벤트가 버블링이 되도록 하기 위해서는 어떤 프로퍼티를 true로 만들어야할까?
    * composed
    
7. 정규표현식
    * 정규표현식은 직접 테스트해본 예시를 가지고 질문 만들기

    ```javascript
    let value;

    // 1. 패턴과 플래그

    console.log("Hi there, It's Friday".match(/i/gi));
    console.log("He was, She was, We were".replace(/Was/gi, "is"));
    console.log("I love HTML".replace(/HTML/,"$'CSS and Javascript"));

    // 2. 문자 클래스

    console.log("+1) 123-345-450".match(/\d/g));
    console.log("+1) 123-345-450".match(/\D/g));
    console.log("I am 10 years old".match(/..years old/g));
    console.log("Hi\nHello\nBye".match(/.Bye/g));
    console.log("Hi\nHello\nBye".match(/.Bye/gs));

    // 3. 유니코드: 'u' 플래그와 \p{...} 클래스
    console.log("$3000 vs ₩3500000".match(/\p{Sc}/gu));

    // 4. 문자열의 시작 ^ 과 끝 $
    console.log(/^Hello/.test("Hello It's Friday"));
    console.log(/Friday$/.test("Hello It's Friday"));
    console.log(/^\d\d\d\d-\d\d-\d\d$/.test("2020-02-23"));

    // 5. 앵커 ^와 $의 여러 행 모드, 'm' 플래그
    console.log(/^\d\d\d\d-\d\d-\d\d$/.test("2020-02-23"));
    value = `My name is 3
    Her name is 4
    His name is 123`;
    console.log(value.match(/\d$/gm));

    // 6. Word boundary: \b
    console.log("HTML5, CSS, JavaScript".match(/\bHTML\b/g));
    console.log("1, 23 4 53-1433".match(/\b\d\d\b/g));

    // 7. Escaping, special characters
    console.log("Hello *^^*".match(/\*\^\^\*/g));

    // 8. Sets and ranges
    console.log("\*^^*/ $3000.00 || (hi?) 2+2".match(/[\\\*\^\$\.\|\(\)\?\+]/g));
    console.log("A1 B3 C3 D9 Z1".match(/[A-C1-3][A-C1-3]/g));
    console.log("A1 B3 C3 D9 Z1".match(/\w\w/g));
    console.log("A1 B3 C3 F9 Z9".match(/\b[^A-C1-3][^A-C1-3]\b/g));

    // 9. Quantifiers +, *, ? and {n}
    console.log("1 12 123 1234 12345 123456".match(/\d{3}/g));
    console.log("1 12 123 1234 12345 123456".match(/\d{3,5}/g));
    console.log("1 12 123 1234 12345 123456".match(/\d{3,}/g));
    console.log("1 12 123 1234 12345 123456".match(/\d{1,}/g));

    console.log("Helloo! Hello!".match(/Hell?o/g));
    console.log("300 100 10 1 3 301".match(/\d0*/g));

    // 10. Greedy and lazy quantifiers
    /*
    * matching mode를 greedy가 아니라 lazy로 바꾸려면 어떤 연산자를 쓰면 될까?
    */
    console.log('She said, "Hello", and he said, "Bye"'.match(/".+"/g));
    console.log('She said, "Hello", and he said, "Bye"'.match(/".+?"/g));
    console.log("123 456".match(/\d+ \d+/g));
    console.log("123 456".match(/\d+ \d+?/g));
    console.log('She said, "Hello", and he said, "Bye"'.match(/"[^"]+"/g));

    // 11. Capturing groups
    /*
    * 패턴의 일부를 괄호로 묶을 수 있음 
    */
    console.log("Gogogo now!".replace(/(go)+/gi, 'Go'));
    console.log("Hello Hi".replace(/(\w+) (\w+)/, '$2, $1'));

    // 12. Backreferences in pattern: \N and \k<name>
    console.log(`She said, "Hello, I'm Lucy", and he said, "Bye"`.match(/(['"])(.*?)\1/g));
    console.log(`She said, "Hello, I'm Lucy", and he said, "Bye"`.match(/(?<ref>['"])(.*?)\k<ref>/g));

    // 13. Alternation (OR) |
    console.log("00:01 10:10 23:59 24:24 25:25 1:2 1:22".match(/([01]\d|2[0-3]):[0-5]\d/g));

    // 14. Lookahead and lookbehind

    console.log("카카오택시는 10000원 우버는 $20".match(/\d+(?=원)/g));
    console.log("카카오택시는 10000원 우버는 $20".match(/\d+(?!원)/g));
    console.log("카카오택시는 10000원 우버는 $20".match(/(?<=\$)\d+/g));
    console.log("카카오택시는 10000원 우버는 $20".match(/(?<!\$)\d+/g));
    console.log("카카오택시는 10000원 우버는 $20".match(/(?<=\$)\d+|\d+(?=원)/g));

    // 15. Catastrophic backtracking
    /*
    * 정규표현식의 역추적이란 무엇이고, 역추적을 방지하는 방법은?
    */

    // 16. Sticky flag "y", searching at position
    let regexp = /\w+/y;
    regexp.lastIndex = 6;
    console.log(regexp.exec("hello hi bye"));

    // 17. Methods of RegExp and String
    console.log('12, 34,\n56, \n  33'.split(/,\s*/));
    ```
